{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\nvar CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValuesAsync(input) {\n  var output, bytes, i;\n  return _regeneratorRuntime.async(function getRandomValuesAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          output = input;\n          if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(Random.getRandomBytesAsync(input.length));\n\n        case 4:\n          bytes = _context.sent;\n\n          for (i = 0; i < bytes.length; i++) {\n            input[i] = bytes[i];\n          }\n\n          return _context.abrupt(\"return\", output);\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction convertBufferToString(buffer) {\n  var state = [];\n\n  for (var i = 0; i < buffer.byteLength; i += 1) {\n    var index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64) {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandomAsync(size) {\n  var buffer;\n  return _regeneratorRuntime.async(function generateRandomAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          buffer = new Uint8Array(size);\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(getRandomValuesAsync(buffer));\n\n        case 3:\n          return _context2.abrupt(\"return\", convertBufferToString(buffer));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function deriveChallengeAsync(code) {\n  var buffer;\n  return _regeneratorRuntime.async(function deriveChallengeAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n            encoding: Crypto.CryptoEncoding.BASE64\n          }));\n\n        case 3:\n          buffer = _context3.sent;\n          return _context3.abrupt(\"return\", convertToUrlSafeString(buffer));\n\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function buildCodeAsync() {\n  var size,\n      codeVerifier,\n      codeChallenge,\n      _args4 = arguments;\n  return _regeneratorRuntime.async(function buildCodeAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          size = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : 128;\n          _context4.next = 3;\n          return _regeneratorRuntime.awrap(generateRandomAsync(size));\n\n        case 3:\n          codeVerifier = _context4.sent;\n          _context4.next = 6;\n          return _regeneratorRuntime.awrap(deriveChallengeAsync(codeVerifier));\n\n        case 6:\n          codeChallenge = _context4.sent;\n          return _context4.abrupt(\"return\", {\n            codeVerifier: codeVerifier,\n            codeChallenge: codeChallenge\n          });\n\n        case 8:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function generateHexStringAsync(size) {\n  var value, buffer;\n  return _regeneratorRuntime.async(function generateHexStringAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return _regeneratorRuntime.awrap(generateRandomAsync(size));\n\n        case 2:\n          value = _context5.sent;\n          _context5.next = 5;\n          return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n            encoding: Crypto.CryptoEncoding.HEX\n          }));\n\n        case 5:\n          buffer = _context5.sent;\n          return _context5.abrupt(\"return\", convertToUrlSafeString(buffer));\n\n        case 7:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/PKCE.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nasync function getRandomValuesAsync(input: Uint8Array): Promise<Uint8Array> {\n  const output = input;\n  // Get access to the underlying raw bytes\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n\n  const bytes = await Random.getRandomBytesAsync(input.length);\n\n  for (let i = 0; i < bytes.length; i++) input[i] = bytes[i];\n\n  return output;\n}\n\nfunction convertBufferToString(buffer: Uint8Array): string {\n  const state: string[] = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    const index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64: string): string {\n  return b64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nexport async function generateRandomAsync(size: number): Promise<string> {\n  const buffer = new Uint8Array(size);\n  // TODO(Bacon): Change this to be sync in the future when Expo unimodules support sync methods\n  await getRandomValuesAsync(buffer);\n  return convertBufferToString(buffer);\n}\n\n/**\n * Proof key for Code Exchange by OAuth Public Clients (RFC 7636), Section 4.1\n * [Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1)\n */\nexport async function deriveChallengeAsync(code: string): Promise<string> {\n  // 43 is the minimum, and 128 is the maximum.\n  invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n    encoding: Crypto.CryptoEncoding.BASE64,\n  });\n  return convertToUrlSafeString(buffer);\n}\n\nexport async function buildCodeAsync(\n  size: number = 128\n): Promise<{ codeChallenge: string; codeVerifier: string }> {\n  // This method needs to be resolved like all other native methods.\n  const codeVerifier = await generateRandomAsync(size);\n  const codeChallenge = await deriveChallengeAsync(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Digest a random string with hex encoding, useful for creating `nonce`s.\n */\nexport async function generateHexStringAsync(size: number): Promise<string> {\n  const value = await generateRandomAsync(size);\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n    encoding: Crypto.CryptoEncoding.HEX,\n  });\n  return convertToUrlSafeString(buffer);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}