{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { CodedError } from '@unimodules/core';\nimport { CryptoEncoding } from \"./Crypto.types\";\nexport default {\n  get name() {\n    return 'ExpoCrypto';\n  },\n\n  digestStringAsync: function digestStringAsync(algorithm, data, options) {\n    var encoder, buffer, hashedData;\n    return _regeneratorRuntime.async(function digestStringAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (crypto.subtle) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new CodedError('ERR_CRYPTO_UNAVAILABLE', 'Access to the WebCrypto API is restricted to secure origins (https).');\n\n          case 2:\n            encoder = new TextEncoder();\n            buffer = encoder.encode(data);\n            _context.next = 6;\n            return _regeneratorRuntime.awrap(crypto.subtle.digest(algorithm, buffer));\n\n          case 6:\n            hashedData = _context.sent;\n\n            if (!(options.encoding === CryptoEncoding.HEX)) {\n              _context.next = 11;\n              break;\n            }\n\n            return _context.abrupt(\"return\", hexString(hashedData));\n\n          case 11:\n            if (!(options.encoding === CryptoEncoding.BASE64)) {\n              _context.next = 13;\n              break;\n            }\n\n            return _context.abrupt(\"return\", btoa(String.fromCharCode.apply(String, _toConsumableArray(new Uint8Array(hashedData)))));\n\n          case 13:\n            throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\n\nfunction hexString(buffer) {\n  var byteArray = new Uint8Array(buffer);\n\n  var hexCodes = _toConsumableArray(byteArray).map(function (value) {\n    var hexCode = value.toString(16);\n    var paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}","map":{"version":3,"sources":["../src/ExpoCrypto.web.ts"],"names":[],"mappings":";;AAAA,SAAS,UAAT,QAA2B,kBAA3B;AAEA,SAAgC,cAAhC;AAEA,eAAe;AACb,MAAI,IAAJ,GAAQ;AACN,WAAO,YAAP;AACD,GAHY;;AAIP,EAAA,iBAJO,6BAKX,SALW,EAMX,IANW,EAOX,OAPW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBASN,MAAM,CAAC,MATD;AAAA;AAAA;AAAA;;AAAA,kBAUH,IAAI,UAAJ,CACJ,wBADI,EAEJ,sEAFI,CAVG;;AAAA;AAeL,YAAA,OAfK,GAeK,IAAI,WAAJ,EAfL;AAgBL,YAAA,MAhBK,GAgBI,OAAO,CAAC,MAAR,CAAe,IAAf,CAhBJ;AAAA;AAAA,6CAiBc,MAAM,CAAC,MAAP,CAAc,MAAd,CAAqB,SAArB,EAAgC,MAAhC,CAjBd;;AAAA;AAiBL,YAAA,UAjBK;;AAAA,kBAkBP,OAAO,CAAC,QAAR,KAAqB,cAAc,CAAC,GAlB7B;AAAA;AAAA;AAAA;;AAAA,6CAmBF,SAAS,CAAC,UAAD,CAnBP;;AAAA;AAAA,kBAoBA,OAAO,CAAC,QAAR,KAAqB,cAAc,CAAC,MApBpC;AAAA;AAAA;AAAA;;AAAA,6CAqBF,IAAI,CAAC,MAAM,CAAC,YAAP,OAAA,MAAM,qBAAiB,IAAI,UAAJ,CAAe,UAAf,CAAjB,EAAP,CArBF;;AAAA;AAAA,kBAuBL,IAAI,UAAJ,CAAe,mBAAf,EAAoC,iCAApC,CAvBK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAf;;AA2BA,SAAS,SAAT,CAAmB,MAAnB,EAAsC;AACpC,MAAM,SAAS,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAlB;;AAEA,MAAM,QAAQ,GAAG,mBAAI,SAAJ,EAAe,GAAf,CAAmB,UAAA,KAAK,EAAG;AAC1C,QAAM,OAAO,GAAG,KAAK,CAAC,QAAN,CAAe,EAAf,CAAhB;AACA,QAAM,aAAa,GAAG,OAAO,CAAC,QAAR,CAAiB,CAAjB,EAAoB,GAApB,CAAtB;AACA,WAAO,aAAP;AACD,GAJgB,CAAjB;;AAMA,SAAO,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAP;AACD","sourcesContent":["import { CodedError } from '@unimodules/core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nexport default {\n  get name(): string {\n    return 'ExpoCrypto';\n  },\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    if (!crypto.subtle) {\n      throw new CodedError(\n        'ERR_CRYPTO_UNAVAILABLE',\n        'Access to the WebCrypto API is restricted to secure origins (https).'\n      );\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map(value => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}